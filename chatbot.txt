Long ago, a great wall was built along the northern border of an ancient kingdom. After the wall was finished, an artist walked along the wall from west to east, decorating the southern side of each top brick with a unique symbol.

The artist's apprentice was instructed to follow and copy each symbol onto the northern side of each brick. However, instead of copying each symbol onto the back of the same brick, the apprentice accidentally copied the symbol onto the back of the next brick along to the east. That is, he drew the symbol from southern side of the first brick onto the northern side of the second brick, the symbol from the southern side of the second brick onto the northern side of the third brick, and so forth all the way along the wall. When he reached the eastern end, he realised his mistake, as there was no brick on which to draw the final symbol. In panic, he removed the first brick from the wall, and destroyed it.

The years passed, and the local people gave names to the symbols decorating the wall. They carved these names beneath the symbol on (both sides of) each brick. Many years later, an earthquake shook the kingdom, and the wall came crashing down. Dismayed, the King ordered all of the decorated bricks to be brought to his palace. Upon examining the heap of bricks, the Royal Data Scientist observed that it was readily apparent which was the north and south side of each brick, as exposure to sunlight had caused the symbols on one side of the wall to fade more than the other. Thus there was enough information to efficiently determine the original sequence of symbols.

The Royal Software Engineer noted that processing the symbol names would be more efficient than processing images of the symbols, and proposed the following algorithm for computing the original sequence:

Load the information from each brick into main memory, organising it in a manner suitable for efficient searching.
Arbitrarily choose one of the bricks as a starting point.
Taking the two symbol names from the starting brick, start constructing a result sequence elsewhere in main memory, northern name followed by southern name.
Repeatedly, until no matching brick is found:
Search for the brick with a northern symbol that matches the back (easternmost) symbol in the result sequence.
Add the southern symbol name from that brick to the back of the result sequence.
Repeatedly, until no matching brick is found:
Search for the brick with a southern symbol that matches the front (westernmost) symbol in the result sequence.
Add the northern symbol name from that brick to the front of the result sequence.


write an example program in c++ by making use of one or more of the following standard library containers: std::vector, std::list, std::map, std::unordered_map, implement the Royal Software Engineer's algorithm in the way that you think will have the most efficient time performance at runtime (in the average case).




Unfortunately, the Royal Hardware Engineer then raised an objection: the main memory of current hardware was insufficient to hold all of the data. The only storage medium available large enough for a dataset of this size were tape drives. These tape drives only supported sequential access, not random access, which might be problematic for implementing efficient searching.

After some further discussion and head scratching, they decided to ask the Royal Mathematician. This was with some trepidation, as the Royal Mathematician had a reputation for poor variable names.

"Well," said the Royal Mathematician, "here is a suitable algorithm:

Let N be the total number of symbols. Start by putting the pairs of symbol names from the bricks on a tape, let's call this tape A. Then make another copy of this tape, let's call it tape B. Now sort tape A alphabetically by the second components of the pairs, and sort tape B alphabetically by the first components.

If we examine these tapes side-by-side, we will see that the second components of the pairs in tape A mostly match up with the first components of the pairs in tape B, except for in two places where a symbol is missing. These two places must be the bricks from the easternmost and westernmost ends of the wall, as they are the only bricks that do not have a matching symbol. From the matching of symbols, we can now produce a set of pairs of symbols two positions apart. We can then keep repeating this process, each time finding twice as many bricks, and matching positions twice as far apart.

We will record the positions of the symbols on a tape, let's call it tape P, in pairs of the form (Symbol Name, Position Number). We will also need another tape, let's call it tape C, for recording the symbols twice as far apart. For simplicity, let's just work from the eastern end of the sequence.

In detail, until we reach the end of tape A, iterate through tapes A and B as follows. Let us refer to the current pairs on tapes A and B as (a1, a2) and (b1, b2), respectively. Then:

If a2 = b1, append (a1, b2) to tape C, and advance tapes A and B.
Else if a2 < b1, append (a1, N-1) and (a2, N) to tape P, and advance tape A.
Else if a2 > b1, advance tape B.
When we reach the end of tape A, sort tape P alphabetically by the first components of the pairs.

We now keep repeating a similar process, but using pairs of symbols twice as far apart at each iteration. We will denote this distance as d, starting at 2. We will also use an additional tape F to store newly found positions.

While d < N:

Overwrite tapes A and B with copies of tape C.
Erase tape C.
Sort tape A alphabetically by the second components of the pairs, and sort tape B alphabetically by the first components.
Until we reach the end of tape A, iterate through tapes A, B and P, as follows. Let us refer to the current pairs on tapes A, B and P, as (a1, a2), (b1, b2) and (p1, p2), respectively. Then:
If a2 = b1, append (a1, b2) to tape C, and advance tapes A and B.
Else if a2 = p1, append (a1, p2-d) to tape F, and advance tapes A and P.
Else if a2 > p1, advance tape P.
Else if a2 > b1, advance tape B.
Sort tape F alphabetically by its first components;
Merge the contents of tape F into tape P (preserving alphabetical ordering of first components);
Erase tape F.
Increase d to 2d.
Thus d increases 2, 4, 8, 16, etc., until eventually d â‰¥ N, at which point tape A is empty and tape P contains the position numbers of all of the symbols.

Finally, we sort tape P numerically by its second components (the position numbers), and then copy the first components (the symbol names) from tape P onto a final results tape."

"Hmmm," said the Royal Software Engineer, "that's very clever. But you'll have to be careful to check that you haven't reached the end of tapes B or P in those if-conditions, otherwise you might make an out-of-bounds access."
Implement the revised Royal Mathematician's Algorithm in C++.

You may simulate the tape drives using 'std::list' from the standard library.
You may use 'std::list::sort()' and 'std::list::merge()' in the same manner that the Royal Mathematician does.